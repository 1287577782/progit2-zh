[[_setting_up_server]]
=== 配置服务器

我们来看看如何在服务器端设置 SSH 的访问。
在这个例子中，你将会使用 `authorized_keys` 来对你的用户进行认证。
我们也假设你正在使用一个 Ubuntu 之类的标准 Linux 发行版。
首先，创建一个 `git` 用户并在那个用户的用户文件夹下创建 `.ssh` 目录。

[source,console]
----
$ sudo adduser git
$ su git
$ cd
$ mkdir .ssh && chmod 700 .ssh
$ touch .ssh/authorized_keys && chmod 600 .ssh/authorized_keys
----

接下来，你需要将一些开发者的 SSH 公钥添加到 `git` 用户的 `authorized_keys` 文件中。
我们假设你已经获得了一些受信任的公钥，并将它们保存到了临时文件中。
同样地，这些公钥看起来是这样的：

[source,console]
----
$ cat /tmp/id_rsa.john.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
dAv8JggJICUvax2T9va5 gsg-keypair
----

你只需要将它们追加到 `git` 用户 `.ssh` 目录中的 `authorized_keys` 文件里。

[source,console]
----
$ cat /tmp/id_rsa.john.pub >> ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.josie.pub >> ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.jessica.pub >> ~/.ssh/authorized_keys
----

现在，你可以通过运行带有 `--bare` 选项的 `git init` 命令为他们创建一个空仓库，这样你就能在没有工作目录的情况下初始化仓库：(((git commands, init, bare)))

[source,console]
----
$ cd /opt/git
$ mkdir project.git
$ cd project.git
$ git init --bare
Initialized empty Git repository in /opt/git/project.git/
----

然后，John，Josie 和 Jessica 能够通过将这个仓库设置为远程仓库并创建一个新分支来将他们项目的最初版本推送到这个仓库中。
请注意，如果要添加一个新项目，必须要有人通过 shell 连接到服务器并创建一个裸仓库。
现在让我们使用 `gitserver` 作为你设置了 `git` 用户和仓库的服务器的主机名。
如果你正在内网运行这个服务器并在 DNS 中将 `gitserver` 指向了这个服务器，那么你就可以像这样使用如下命令（假设 `myproject` 已经存在并且其中有文件包含）：

[source,console]
----
# on Johns computer
$ cd myproject
$ git init
$ git add .
$ git commit -m 'initial commit'
$ git remote add origin git@gitserver:/opt/git/project.git
$ git push origin master
----

此时，其他用户能同样简单地克隆这个仓库并将改动推回来：

[source,console]
----
$ git clone git@gitserver:/opt/git/project.git
$ cd project
$ vim README
$ git commit -am 'fix for the README file'
$ git push origin master
----

通过这种方法，你可以快速地搭建一个具有读／写权限的 Git 服务器并让它为一群开发者服务。

你需要注意的是，目前这些用户也可以使用这个 `git` 用户登录进服务器并且获得一个 shell。如果你想对此加以限制，你还需要修改 `passwd` 文件中的 shell。

你可以简单地通过一个与 Git 一同安装的名为 `git-shell` 的受限的 shell 来限制 'git' 用户以使其只能进行 Git 活动。
如果你将其设置为 `git` 用户的登录 shell，那么该用户便不能获得你机器正常的 shell 访问权限。
要使用 `git-shell`，请指定 `git-shell` 为用户的登录 shell，而不是 bash、csh 等一般 shell。 
要进行此操作，如果 `/etc/shells` 中不存在 `git-shell`，你必须将 `git-shell` 添加到其中：

[source,console]
----
$ cat /etc/shells   # see if `git-shell` is already in there.  If not...
$ which git-shell   # make sure git-shell is installed on your system.
$ sudo vim /etc/shells  # and add the path to git-shell from last command
----

现在，你可以使用 `chsh <username>` 命令改变一个用户的 shell：

[source,console]
----
$ sudo chsh git  # and enter the path to git-shell, usually: /usr/bin/git-shell
----

现在，用户 `git` 只能使用 SSH 连接对 Git 仓库进行 push/pull 操作，而不能通过 shell 控制机器。
试一试，你会发现如下的登录拒绝信息：

[source,console]
----
$ ssh git@gitserver
fatal: Interactive git shell is not enabled.
hint: ~/git-shell-commands should exist and have read and execute access.
Connection to gitserver closed.
----

现在 Git 的网络命令依然能够正常工作，但是用户不能得到一个普通 shell。
如同输出中所说，你可以在“git”用户的用户目录下建立一个文件夹来对 `git-shell` 命令进行一定程度上的自定义。
比如，你可以限制服务器可以接受的 Git 命令，或者自定义用户以类似方式尝试 SSH 登录时所看到的信息。
要了解更多有关自定义 shell 的信息，请运行 `git help shell`。(((git commands, help)))
