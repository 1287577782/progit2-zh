=== 分布式工作流程

(((workflows)))
Unlike Centralized Version Control Systems (CVCSs), the distributed nature of Git allows you to be far more flexible in how developers collaborate on projects.
同传统的集中式版本控制系统（CVCS）不同，Git 的分布式特性使得开发者间的协作变得更加灵活多样。
In centralized systems, every developer is a node working more or less equally on a central hub.
在集中式系统中，每个开发者就像是连接在集线器上的节点，彼此的工作方式大体相像。
In Git, however, every developer is potentially both a node and a hub – that is, every developer can both contribute code to other repositories and maintain a public repository on which others can base their work and which they can contribute to.
而在 Git 网络中，每个开发者同时扮演着节点和集线器的角色 - 也就是说，每个开发者都可以将自己的代码贡献到其他的仓库中，同时维护自己的公有仓库，让其他人可以在其基础上工作并贡献代码。
This opens a vast range of workflow possibilities for your project and/or your team, so we'll cover a few common paradigms that take advantage of this flexibility.
由此你的项目和团队可以衍生出种种不同的工作流程，接下来会介绍几种常见的应用方式，它们都利用了 Git 的这种灵活的特性。
We'll go over the strengths and possible weaknesses of each design; you can choose a single one to use, or you can mix and match features from each.
我们将讨论每种方式的优缺点，你可以选择其中的一种，或者将每种的方式的特性结合起来使用。

==== 集中式工作流

(((workflows, centralized)))
In centralized systems, there is generally a single collaboration model–the centralized workflow.
集中式系统中通常使用的是单点协作模型 — 集中式工作流。
One central hub, or repository, can accept code, and everyone synchronizes their work to it.
一个中心集线器，或者说仓库，用于接收代码，以同步所有人的工作。
A number of developers are nodes – consumers of that hub – and synchronize to that one place.
所有的开发者都是普通的节点，作为中心仓库的消费者，平时的工作就是在同一个地方同步数据。

.集中式工作流.
image::images/centralized.png[集中式工作流]

This means that if two developers clone from the hub and both make changes, the first developer to push their changes back up can do so with no problems.
这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。
The second developer must merge in the first one's work before pushing changes up, so as not to overwrite the first developer's changes.
第二个开发者在推送修改之前，必须先下载合并第一个人的数据，解决冲突之后方可以推送，这样才不会覆盖第一个人的修改。
This concept is as true in Git as it is in Subversion(((Subversion))) (or any CVCS), and this model works perfectly well in Git.
这和 Subversion(((Subversion))) （或任何 CVCS）中的概念一样，而且这个模式也可以很好地运用到 Git 中。

If you are already comfortable with a centralized workflow in your company or team, you can easily continue using that workflow with Git.
如果你已经习惯了公司或者团队的集中式工作流程，完全可以继续采用这种简单的模式。
Simply set up a single repository, and give everyone on your team push access; Git won't let users overwrite each other.
只需要搭建好一个中心仓库，并给开发团队中的每个人推送数据的权限，就可以开展工作了。 Git 不会让用户覆盖彼此的代码。
Say John and Jessica both start working at the same time.
例如 John 和 Jessica 同时开始工作。
John finishes his change and pushes it to the server.
John 完成了他的修改并将数据推送到服务器。
Then Jessica tries to push her changes, but the server rejects them.
接着 Jessica 尝试提交她自己的修改，却遭到服务器的拒绝。
She is told that she's trying to push non-fast-forward changes and that she won't be able to do so until she fetches and merges.
她被告知她的修改正在通过非快进式（non-fast-forward）的方式推送，只有将数据抓取下来并且合并后方能推送。
This workflow is attractive to a lot of people because it's a paradigm that many are familiar and comfortable with.
大多数人都熟悉和习惯这种模式的工作流程，所以它的使用也非常广泛。

This is also not limited to small teams. With Git's branching model, it's possible for hundreds of developers to successfully work on a single project through dozens of branches simultaneously.
当然这并不局限于小团队。利用 Git 的分支模型，通过同时在多个分支上工作的方式，即使是上百人的开发团队也可以很好的在单个项目上协作。

[[_integration_manager]]
==== 集成管理者工作流

(((workflows, integration manager)))
Because Git allows you to have multiple remote repositories, it's possible to have a workflow where each developer has write access to their own public repository and read access to everyone else's.
由于 Git 允许使用多个远程仓库，开发者便可以建立自己的公共仓库，往里面写数据并共享给他人，而同时又可以读取别人仓库中的数据。
This scenario often includes a canonical repository that represents the ``official'' project.
这种情形通常会有个权威的仓库（blessed repository）代表``官方''的项目。
To contribute to that project, you create your own public clone of the project and push your changes to it.
要为这个项目做贡献，你需要从该项目克隆出一个自己的公共仓库（developer public），然后将自己的修改推送上去。
Then, you can send a request to the maintainer of the main project to pull in your changes.
接着你可以请求官方仓库的维护者拉取更新合并到主项目。
The maintainer can then add your repository as a remote, test your changes locally, merge them into their branch, and push back to their repository.
维护者可以将你的仓库作为远程仓库添加进来，在本地的克隆仓库（integration manager）将你的修改测试无误后合并到自己的分支，然后再推送到官方仓库。
The process works as follows (see <<wfdiag_b>>):
这一流程的工作方式如下所示（见 <<wfdiag_b>>）：

1.  The project maintainer pushes to their public repository.
1.  项目维护者推送数据到公共仓库 blessed repository。
2.  A contributor clones that repository and makes changes.
2.  贡献者克隆此仓库，做出修改。
3.  The contributor pushes to their own public copy.
3.  贡献者将数据推送到自己的公共仓库 developer public。
4.  The contributor sends the maintainer an e-mail asking them to pull changes.
4.  贡献者给维护者发送邮件，请求拉取自己的更新。
5.  The maintainer adds the contributor's repo as a remote and merges locally.
5.  维护者将贡献者的仓库加为远程仓库并在本地合并 integration manger 。
6.  The maintainer pushes merged changes to the main repository.
6.  维护者将合并后的修改推送到主仓库 blessed repository。

[[wfdiag_b]]
.集成管理员工作流.
image::images/integration-manager.png[Integration-manager workflow.]

(((forking)))
This is a very common workflow with hub-based tools like GitHub or GitLab, where it's easy to fork a project and push your changes into your fork for everyone to see.
这是 GitHub 和 GitLab 等集线器式（hub-based）工具最常用的工作流程。人们可以容易地将某个项目衍生成为自己的公共仓库，想这个仓库推送自己的修改并为每个人所见。
One of the main advantages of this approach is that you can continue to work, and the maintainer of the main repository can pull in your changes at any time.
这么做最主要的优点之一是你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。
Contributors don't have to wait for the project to incorporate their changes – each party can work at their own pace.
贡献者不必等待维护者处理完提交的更新 - 每一方都可以按照自己节奏工作。

==== 司令官与副官工作流

(((workflows, dictator and lieutenants)))
This is a variant of a multiple-repository workflow.
这其实是上一种工作流的变体。
It's generally used by huge projects with hundreds of collaborators; one famous example is the Linux kernel.
一般拥有数百协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。
Various integration managers are in charge of certain parts of the repository; they're called lieutenants.
各个集成管理者分别负责集成项目中的特定部分，称为副官（lieutenant）。
All the lieutenants have one integration manager known as the benevolent dictator.
而所有这些副官头上还有一位负责统筹的总集成管理者，称为司令官（dictator）。
The benevolent dictator's repository serves as the reference repository from which all the collaborators need to pull.
司令官维护的仓库作为参考仓库，用于为所有协作者提供他们需要拉取的项目代码。
The process works like this (see <<wfdiag_c>>):
整个流程看起来是这样的(见 <<wfdiag_c>>):

1.  Regular developers work on their topic branch and rebase their work on top of `master`.
    The `master` branch is that of the dictator.
1.  一般的开发者在自己的特性分支上工作，并不定期地根据司令官的 `master` 分支衍合。
2.  Lieutenants merge the developers' topic branches into their `master` branch.
2.  副官将普通开发者的特性分支合并到自己的 `master` 分支中。
3.  The dictator merges the lieutenants' `master` branches into the dictator's `master` branch.
3.  司令官将所有副官的 `master` 分支并入自己的 `master` 分支。
4.  The dictator pushes their `master` to the reference repository so the other developers can rebase on it.
4.  司令官将集成后的 `master` 分支推送到参考仓库 blessed repository 中，以便所有其他开发者以此为基础进行衍合。

[[wfdiag_c]]
.司令官与副官工作流.
image::images/benevolent-dictator.png[司令官与副官工作流.]

This kind of workflow isn't common, but can be useful in very big projects, or in highly hierarchical environments.
这种工作流程并不常用，只有当项目极为庞杂，或者需要多级别管理时，才会体现出优势。
It allows the project leader (the dictator) to delegate much of the work and collect large subsets of code at multiple points before integrating them.
利用这种方式，项目总负责人（即司令官）可以把大量分散的集成工作委托给不同的小组负责人分别处理，在不同时刻将大块的代码子集统筹起来用于之后的整合。

==== Workflows Summary

These are some commonly used workflows that are possible with a distributed system like Git, but you can see that many variations are possible to suit your particular real-world workflow.
上面介绍了在 Git 等常见的分布式系统中可行并且经常使用的工作流程。在实际的开发过程中，你可能会遇到可以满足特定需求的各种工作流变种。
Now that you can (hopefully) determine which workflow combination may work for you, we'll cover some more specific examples of how to accomplish the main roles that make up the different flows.
至此，希望你已经清楚自己需要哪种方式开展工作了，接下来我们将看看不同工作流中的每个角色具体应该如何操作。
In the next section, you'll learn about a few common patterns for contributing to a project.
下一节我们将会学习为项目做贡献的一些常用模式。
