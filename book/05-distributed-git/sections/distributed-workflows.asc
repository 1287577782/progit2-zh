=== 分布式工作流程

(((workflows)))
同传统的集中式版本控制系统（CVCS）不同，Git 的分布式特性使得开发者间的协作变得更加灵活多样。
在集中式系统中，每个开发者就像是连接在集线器上的节点，彼此的工作方式大体相像。
而在 Git 中，每个开发者同时扮演着节点和集线器的角色 - 也就是说，每个开发者都可以将自己的代码贡献到其他的仓库中，同时维护自己的公有仓库，让其他人可以在其基础上工作并贡献代码。
由此你的项目和团队可以衍生出种种不同的工作流程，接下来会介绍几种常见的应用方式，它们都利用了 Git 的这种灵活的特性。
我们将讨论每种方式的优缺点，你可以选择其中的一种，或者将每种的方式的特性结合起来使用。

==== 集中式工作流

(((workflows, centralized)))
集中式系统中通常使用的是单点协作模型 — 集中式工作流。
一个中心集线器，或者说仓库，用于接收代码，以同步所有人的工作。
所有的开发者都是普通的节点，作为中心仓库的消费者，平时的工作就是在同一个地方同步数据。

.集中式工作流.
image::images/centralized.png[集中式工作流]

这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。
第二个开发者在推送修改之前，必须先下载合并第一个人的数据，解决冲突之后才可以推送，这样才不会覆盖第一个人的修改。
这和 Subversion(((Subversion))) （或任何 CVCS）中的概念一样，而且这个模式也可以很好地运用到 Git 中。

如果你已经习惯了公司或者团队的集中式工作流程，完全可以继续采用这种简单的模式。
只需要搭建好一个中心仓库，并给开发团队中的每个人推送数据的权限，就可以开展工作了。 Git 不会让用户覆盖彼此的代码。
例如 John 和 Jessica 同时开始工作。
John 完成了他的修改并将数据推送到服务器。
接着 Jessica 尝试提交她自己的修改，却遭到服务器的拒绝。
她被告知她的修改正在通过非快进式（non-fast-forward）的方式推送，只有将数据抓取下来并且合并后方能推送。
大多数人都熟悉和习惯这种模式的工作流程，所以它的使用也非常广泛。

当然这并不局限于小团队。利用 Git 的分支模型，通过同时在多个分支上工作的方式，即使是上百人的开发团队也可以很好的在单个项目上协作。

[[_integration_manager]]
==== 集成管理者工作流

(((workflows, integration manager)))
由于 Git 允许使用多个远程仓库，开发者便可以建立自己的公共仓库，往里面写数据并共享给他人，而同时又可以读取别人仓库中的数据。
这种情形通常会有个权威的仓库（blessed repository）代表``官方''的项目。
要为这个项目做贡献，你需要从该项目克隆出一个自己的公共仓库（developer public），然后将自己的修改推送上去。
接着你可以请求官方仓库的维护者拉取更新合并到主项目。
维护者可以将你的仓库作为远程仓库添加进来，在本地的克隆仓库（integration manager）将你的修改测试无误后合并到自己的分支，然后再推送到官方仓库。
这一流程的工作方式如下所示（见 <<wfdiag_b>>）：

1.  项目维护者推送数据到公共仓库（blessed repository）。
2.  贡献者克隆此仓库，做出修改。
3.  贡献者将数据推送到自己的公共仓库（developer public）。
4.  贡献者给维护者发送邮件，请求拉取自己的更新。
5.  维护者将贡献者的仓库加为远程仓库并在本地合并（integration manger） 。
6.  维护者将合并后的修改推送到主仓库（blessed repository）。

[[wfdiag_b]]
.集成管理者工作流.
image::images/integration-manager.png[集成管理者工作流.]

(((forking)))
这是 GitHub 和 GitLab 等集线器式（hub-based）工具最常用的工作流程。人们可以容易地将某个项目衍生成为自己的公共仓库，向这个仓库推送自己的修改，并为每个人所见。
这么做最主要的优点之一是你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。
贡献者不必等待维护者处理完提交的更新 – 每一方都可以按照自己节奏工作。

==== 司令官与副官工作流

(((workflows, dictator and lieutenants)))
这其实是上一种工作流的变体。
一般拥有数百协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。
各个集成管理者分别负责集成项目中的特定部分，称为副官（lieutenant）。
而所有这些副官头上还有一位负责统筹的总集成管理者，称为司令官（dictator）。
司令官维护的仓库作为参考仓库，用于为所有协作者提供他们需要拉取的项目代码。
整个流程看起来是这样的(见 <<wfdiag_c>>):

1.  普通开发者在自己的特性分支上工作，并不定期地根据司令官的 `master` 分支衍合。
2.  副官将普通开发者的特性分支合并到自己的 `master` 分支中。
3.  司令官将所有副官的 `master` 分支并入自己的 `master` 分支中。
4.  司令官将集成后的 `master` 分支推送到参考仓库（blessed repository）中，以便所有其他开发者以此为基础进行衍合。

[[wfdiag_c]]
.司令官与副官工作流.
image::images/benevolent-dictator.png[司令官与副官工作流.]

这种工作流程并不常用，只有当项目极为庞杂，或者需要多级别管理时，才会体现出优势。
利用这种方式，项目总负责人（即司令官）可以把大量分散的集成工作委托给不同的小组负责人分别处理，然后在不同时刻将大块的代码子集统筹起来用于之后的整合。

==== 工作流程总结

上面介绍了在 Git 等常见的分布式系统中可行并且经常使用的工作流程。在实际的开发过程中，你可能会遇到可以满足特定需求的各种工作流变种。
至此，希望你已经清楚自己需要哪种方式开展工作了，接下来我们将看看不同工作流中的每个角色具体应该如何操作。
下一节我们将会学习为项目做贡献的一些常用模式。
