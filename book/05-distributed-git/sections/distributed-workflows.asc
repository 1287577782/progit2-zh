=== 分布式工作流程

Now that you have a remote Git repository set up as a point for all the developers to share their code, and you’re familiar with basic Git commands in a local workflow, you’ll look at how to utilize some of the distributed workflows that Git affords you.
现在我们已经准备好了一台服务器存放远程 Git 仓库便于开发者在其中分享代码。我们已经学会了在本地工作流程中所需用到的一些基本命令，接下来，我们要学习下如何利用 Git 来组织和完成分布式工作流程。

(((workflows)))
Unlike Centralized Version Control Systems (CVCSs), the distributed nature of Git allows you to be far more flexible in how developers collaborate on projects.
同传统的集中式版本控制系统（CVCS）不同，Git 的分布式特性使得开发者间的协作变得更加灵活多样。
In centralized systems, every developer is a node working more or less equally on a central hub.
在集中式系统中，每个开发者就像是连接在集线器上的节点，彼此的工作方式大体相像。
In Git, however, every developer is potentially both a node and a hub – that is, every developer can both contribute code to other repositories and maintain a public repository on which others can base their work and which they can contribute to.
而在Git 网络中，每个开发者同时扮演着节点和集线器的角色 - 也就是说，每个开发者都可以将自己的代码贡献到其他的仓库中，同时维护自己的公有仓库，让其他人可以在其基础上工作并贡献代码。
This opens a vast range of workflow possibilities for your project and/or your team, so we'll cover a few common paradigms that take advantage of this flexibility.
这样的分布式协作方式为你的项目和团队衍生出种种不同的工作流程，接下来的章节会介绍几种常见的应用方式，它们都是利用了 Git 的这种灵活的特性。
We'll go over the strengths and possible weaknesses of each design; you can choose a single one to use, or you can mix and match features from each.
我们将讨论每种方式的优缺点，你可以选择其中的一种，或者将每种的方式的特性结合起来使用。

==== 集中式工作流

(((workflows, centralized)))
In centralized systems, there is generally a single collaboration model–the centralized workflow.
集中式系统中通常使用的是单点协作模型 — 集中式工作流。
One central hub, or repository, can accept code, and everyone synchronizes their work to it.
一个存放代码仓库的中心服务器，用于接收代码，以同步所有人的工作。
A number of developers are nodes – consumers of that hub – and synchronize to that one place.
所有的开发者都是普通的节点，作为中心集线器的消费者，平时的工作就是和中心仓库同步数据。

.集中式工作流.
image::images/centralized.png[集中式工作流]

This means that if two developers clone from the hub and both make changes, the first developer to push their changes back up can do so with no problems.
这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修订，那么只有第一个开发者可以顺利地把数据推送到共享服务器。
The second developer must merge in the first one's work before pushing changes up, so as not to overwrite the first developer's changes.
第二个开发者在推送修订之前，必须先下载合并第一个人的数据，解决冲突之后才能推送数据到共享服务器上。
This concept is as true in Git as it is in Subversion(((Subversion))) (or any CVCS), and this model works perfectly well in Git.
这和 Subversion(((Subversion)))（或任何 CVCS）中的概念一样，而且这个模式在 Git 中也可以很好的使用。

If you are already comfortable with a centralized workflow in your company or team, you can easily continue using that workflow with Git.
如果你的团队不是很大，或者大家都已经习惯了使用集中式工作流程，完全可以继续采用这种简单的模式。
Simply set up a single repository, and give everyone on your team push access; Git won't let users overwrite each other.
只需要配置好一台中心服务器，并给开发团队中的每个人推送数据的权限，就可以开展工作了。 Git 不会让用户覆盖他人的代码。
Say John and Jessica both start working at the same time.
例如John和Jessica同时开始工作。
John finishes his change and pushes it to the server.
John完成了他的修订并将数据推送到服务器。
Then Jessica tries to push her changes, but the server rejects them.
接着Jessica尝试提交她自己的修订，却遭到服务器的拒绝。
She is told that she's trying to push non-fast-forward changes and that she won't be able to do so until she fetches and merges.
她被告知她的修订无法通过快进（fast-forward）的方式推送，只有在将数据获取下来，并且解决冲突合并后方能推送。
This workflow is attractive to a lot of people because it's a paradigm that many are familiar and comfortable with.
大多数人都熟悉和习惯这种模式的工作方式，所以使用也非常广泛。

This is also not limited to small teams. With Git's branching model, it's possible for hundreds of developers to successfully work on a single project through dozens of branches simultaneously.
当然这种方式不局限于小团队。利用 Git 的分支模型，通过同时在多个分支上工作的方式，即使是上百人的开发团队也可以很好的在单个项目上协作。

[[_integration_manager]]
==== 集成管理者工作流

(((workflows, integration manager)))
Because Git allows you to have multiple remote repositories, it's possible to have a workflow where each developer has write access to their own public repository and read access to everyone else's.
由于 Git 允许使用多个远程仓库，开发者便可以建立自己的公共仓库，往里面写数据并共享给他人，而同时又可以读取别人仓库中的数据。
This scenario often includes a canonical repository that represents the ``official'' project.
这种情形通常会有个权威的仓库（blessed repository）代表官方的项目。
To contribute to that project, you create your own public clone of the project and push your changes to it.
要为这个项目做贡献，你需要从该项目的仓库克隆出一个自己的公共仓库（developer public），然后将自己的修改推送上去。
Then, you can send a request to the maintainer of the main project to pull in your changes.
接着你可以请求官方仓库的维护者拉取更新合并到主项目。
The maintainer can then add your repository as a remote, test your changes locally, merge them into their branch, and push back to their repository.
维护者在自己的本地也有个克隆仓库（integration manager），维护者可以将你的仓库作为远程仓库添加进来，在本地将你的修订测试无误后合并到自己的分支，然后再推送到官方仓库。
The process works as follows (see <<wfdiag_b>>):
这一流程的工作方式如下（见 <<wfdiag_b>>）：

1.  The project maintainer pushes to their public repository.
1.  项目维护者推送数据到公共仓库 blessed repository。
2.  A contributor clones that repository and makes changes.
2.  贡献者克隆此仓库，修订或编写新代码。
3.  The contributor pushes to their own public copy.
3.  贡献者推送数据到自己的公共仓库 developer public。
4.  The contributor sends the maintainer an e-mail asking them to pull changes.
4.  贡献者给维护者发送邮件，请求拉取自己的最新修订。
5.  The maintainer adds the contributor's repo as a remote and merges locally.
5.  维护者在自己本地的 integration manger 仓库中，将贡献者的仓库加为远程仓库，合并更新并做测试。
6.  The maintainer pushes merged changes to the main repository.
6.  维护者将合并后的更新推送到主仓库 blessed repository。

[[wfdiag_b]]
.集成管理员工作流.
image::images/integration-manager.png[Integration-manager workflow.]

(((forking)))
This is a very common workflow with hub-based tools like GitHub or GitLab, where it's easy to fork a project and push your changes into your fork for everyone to see.
One of the main advantages of this approach is that you can continue to work, and the maintainer of the main repository can pull in your changes at any time.
Contributors don't have to wait for the project to incorporate their changes – each party can work at their own pace.

==== Dictator and Lieutenants Workflow

(((workflows, dictator and lieutenants)))
This is a variant of a multiple-repository workflow.
It's generally used by huge projects with hundreds of collaborators; one famous example is the Linux kernel.
Various integration managers are in charge of certain parts of the repository; they're called lieutenants.
All the lieutenants have one integration manager known as the benevolent dictator.
The benevolent dictator's repository serves as the reference repository from which all the collaborators need to pull.
The process works like this (see <<wfdiag_c>>):

1.  Regular developers work on their topic branch and rebase their work on top of `master`.
    The `master` branch is that of the dictator.
2.  Lieutenants merge the developers' topic branches into their `master` branch.
3.  The dictator merges the lieutenants' `master` branches into the dictator's `master` branch.
4.  The dictator pushes their `master` to the reference repository so the other developers can rebase on it.

[[wfdiag_c]]
.Benevolent dictator workflow.
image::images/benevolent-dictator.png[Benevolent dictator workflow.]

This kind of workflow isn't common, but can be useful in very big projects, or in highly hierarchical environments.
It allows the project leader (the dictator) to delegate much of the work and collect large subsets of code at multiple points before integrating them.

==== Workflows Summary

These are some commonly used workflows that are possible with a distributed system like Git, but you can see that many variations are possible to suit your particular real-world workflow.
Now that you can (hopefully) determine which workflow combination may work for you, we'll cover some more specific examples of how to accomplish the main roles that make up the different flows.
In the next section, you'll learn about a few common patterns for contributing to a project.
