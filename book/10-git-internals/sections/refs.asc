[[_git_refs]]
=== Git 引用

你可以借助类似于 `git log 1a410e` 这样的命令来浏览完整的提交历史。但是，为了能遍历那段历史并查看全部提交记录，你仍然必须记住 `1a410e` 是最后一个提交记录（的 SHA-1 值）。
你需要一个能把 SHA-1 值映射为一个简单的名字的文件，这样你就可以用那个名字指针来代替原始的 SHA-1 值了。

在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在 `.git/refs` 目录下找到这类含有 SHA-1 值的文件。
在目前的项目中，这个目录暂时没有包含任何文件，但它包含了一个简单的目录结构：

[source,console]
----
$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f
----

从技术上讲，为了创建一个能帮助你记忆最后一个提交记录所在位置的新引用，你只要简单地做如下操作：

[source,console]
----
$ echo "1a410efbd13591db07496601ebc7a059dd55cfe9" > .git/refs/heads/master
----

现在，你已经可以在你的 Git 命令中使用刚刚创建的指向最近那个提交记录的引用来代替相应的 SHA-1 值了：

[source,console]
----
$ git log --pretty=oneline  master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

我们不提倡直接编辑引用文件。
如果你想更新某个引用，Git 提供了一个更加安全的命令 `update-ref` 来完成此事：

[source,console]
----
$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9
----

基本上，这就是 Git 分支的本质：一个指向一系列提交记录的头部（即最近一次提交）的简单指针（或者说引用）。
若想回到第二个提交上并创建一个分支，你可以这么做：

[source,console]
----
$ git update-ref refs/heads/test cac0ca
----

你的分支将只包含从那个提交开始往前追溯的记录：

[source,console]
----
$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

至此，你的 Git 数据库从概念上看起来像这样：

.包含分支引用的 Git 目录对象。
image::images/data-model-4.png[包含分支引用的 Git 目录对象。]

基本上，当你运行类似于 `git branch (branchname)` 这样的命令时，Git 会调用 `update-ref` 命令把当前所在分支最后一个提交记录对应的 SHA-1 值添加到你想要创建的任何新引用中。

[[_the_head]]
==== The HEAD

The question now is, when you run `git branch (branchname)`, how does Git know the SHA-1 of the last commit?
The answer is the HEAD file.

The HEAD file is a symbolic reference to the branch you're currently on.
By symbolic reference, we mean that unlike a normal reference, it doesn’t generally contain a SHA-1 value but rather a pointer to another reference.
If you look at the file, you'll normally see something like this:

[source,console]
----
$ cat .git/HEAD
ref: refs/heads/master
----

If you run `git checkout test`, Git updates the file to look like this:

[source,console]
----
$ cat .git/HEAD
ref: refs/heads/test
----

When you run `git commit`, it creates the commit object, specifying the parent of that commit object to be whatever SHA-1 value the reference in HEAD points to.

You can also manually edit this file, but again a safer command exists to do so: `symbolic-ref`.
You can read the value of your HEAD via this command:

[source,console]
----
$ git symbolic-ref HEAD
refs/heads/master
----

You can also set the value of HEAD:

[source,console]
----
$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test
----

You can't set a symbolic reference outside of the refs style:

[source,console]
----
$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/
----

==== Tags

We just finished discussing Git's three main object types, but there is a fourth.
The tag object is very much like a commit object – it contains a tagger, a date, a message, and a pointer.
The main difference is that a tag object generally points to a commit rather than a tree.
It's like a branch reference, but it never moves – it always points to the same commit but gives it a friendlier name.

As discussed in <<_git_basics_chapter>>, there are two types of tags: annotated and lightweight.
You can make a lightweight tag by running something like this:

[source,console]
----
$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
----

That is all a lightweight tag is – a reference that never moves.
An annotated tag is more complex, however.
If you create an annotated tag, Git creates a tag object and then writes a reference to point to it rather than directly to the commit.
You can see this by creating an annotated tag (`-a` specifies that it's an annotated tag):

[source,console]
----
$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'
----

Here's the object SHA-1 value it created:

[source,console]
----
$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2
----

Now, run the `cat-file` command on that SHA-1 value:

[source,console]
----
$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon <schacon@gmail.com> Sat May 23 16:48:58 2009 -0700

test tag
----

Notice that the object entry points to the commit SHA-1 value that you tagged.
Also notice that it doesn't need to point to a commit; you can tag any Git object.
In the Git source code, for example, the maintainer has added their GPG public key as a blob object and then tagged it.
You can view the public key by running this in a clone of the Git repository:

[source,console]
----
$ git cat-file blob junio-gpg-pub
----

The Linux kernel repository also has a non-commit-pointing tag object – the first tag created points to the initial tree of the import of the source code.

==== Remotes

The third type of reference that you'll see is a remote reference.
If you add a remote and push to it, Git stores the value you last pushed to that remote for each branch in the `refs/remotes` directory.
For instance, you can add a remote called `origin` and push your `master` branch to it:

[source,console]
----
$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -> master
----

Then, you can see what the `master` branch on the `origin` remote was the last time you communicated with the server, by checking the `refs/remotes/origin/master` file:

[source,console]
----
$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949
----

Remote references differ from branches (`refs/heads` references) mainly in that they're considered read-only.
You can `git checkout` to one, but Git won't point HEAD at one, so you'll never update it with a `commit` command.
Git manages them as bookmarks to the last known state of where those branches were on those servers.
