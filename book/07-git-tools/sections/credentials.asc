[[_credential_caching]]
=== 凭证存储

(((credentials)))
(((git commands, credential)))
如果您使用的是 SSH 方式连接远端，并且设置了一个没有口令的密钥，这样就可以在不输入用户名和密码的情况下安全地传输数据。
然而，这对 HTTP 协议来说是不可能的 —— 每一个连接都是需要用户名和密码的。
这在使用双重认证的情况下会更麻烦，因为您需要输入一个随机生成并且毫无规律的 token 作为密码。

幸运的是，Git 拥有一个凭证系统来处理这个事情。
下面有一些 Git 的选项：

* 默认所有都不缓存。
  每一次连接都会询问您的用户名和密码。
* ``cache'' 模式会将凭证存放在内存中一段时间。
  密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。
* ``sotre'' 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。
  这意味着除非您修改了您在 Git 服务器上的密码，否则您永远不需要再次输入您的凭证信息。
  这种方式的缺点是您的密码是用明文的方式存放在您的 home 目录下。
* 如果您使用的是 Mac，Git 还有一种 ``osxkeychain'' 模式，它会将凭证缓存到您系统用户的钥匙串中。
* The ``store'' mode saves the credentials to a plain-text file on disk, and they never expire.
  这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的。
* 如果您使用的是 Windows，您可以安装一个叫做 ``winstore'' 的辅助工具。
  这和上面说的 ``osxkeychain'' 十分类似，但是是使用 Windows Credential Store 来控制敏感信息。
  可以在 https://gitcredentialstore.codeplex.com[] 下载。

您可以设置 Git 的配置来选择上述的一种方式

[source,console]
----
$ git config --global credential.helper cache
----

部分辅助工具有一些选项的。
``store'' 模式可以接受一个 `--file <path>` 参数，可以自定义存放密码的文件路径（默认是`~/.git-credentials`）。
``cache'' 模式有 `--timeout <seconds>` 参数，可以设置后台进程的存活时间（默认是 ``900''，也就是 15 分钟）。
下面是一个配置 ``store'' 模式自定义路径的例子：

[source,console]
----
$ git config --global credential.helper store --file ~/.my-credentials
----

Git 甚至允许您配置多个辅助工具。
当查找特定服务器的凭证时，Git 会按顺序查询，并且在找到第一个回答时停止查询。
当保存凭证时，Git 会将用户名和密码发送给 *所有* 配置列表中的辅助工具，它们会按自己的方式处理用户名和密码。
如果您在闪存上有一个凭证文件，但又希望在该闪存被拔出的情况下使用内存缓存来保存用户名密码，`.gitconfig` 配置文件如下：

[source,ini]
----
[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000
----

==== Under the Hood

这些是如何实现的呢？
Git 凭证辅助工具系统的命令是 `git credential`，这个命令接收一个参数，并通过标准输入获取更多的参数。

举一个例子更容易理解。
我们假设已经配置好一个凭证辅助工具，这个辅助工具保存了 `mygithost` 的凭证信息。
下面是一个使用 ``fill'' 命令的会话，当 Git 尝试寻找一个服务器的凭证时就会被调用。

[source,console]
----
$ git credential fill <1>
protocol=https <2>
host=mygithost
<3>
protocol=https <4>
host=mygithost
username=bob
password=s3cre7
$ git credential fill <5>
protocol=https
host=unknownhost

Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7
----

<1> 这是开始交互的命令。
<2> Git-credential 接下来会等待标准输入。
    我们提供我们所知道的信息：协议和主机名。
<3> 一个空行代表输入已经完成，凭证系统应该输出它所知道的信息。
<4> 接下来由 Git-credential 接管，并且将找到的信息打印到标准输出。
<5> 如果没有找到对应的凭证，Git 会询问用户的用户名和密码，我们将这些信息输入到在标准输出的地方（这个例子中是同一个控制台）。

凭证系统实际上调用的程序和 Git 本身是分开的；具体是哪一个以及如何调用与 `credential.helper` 配置的值有关。
这个配置有多种格式：

[options="header"]
|======
| Configuration Value | Behavior
| `foo` | Runs `git-credential-foo`
| `foo -a --opt=bcd` | Runs `git-credential-foo -a --opt=bcd`
| `/absolute/path/foo -xyz` | Runs `/absolute/path/foo -xyz`
| `!f() { echo "password=s3cre7"; }; f` | Code after `!` evaluated in shell
|======

上面描述的辅助工具可以被称做 `git-credential-cache`、`git-credential-store` 之类，我们可以配置它们来接受命令行参数。
通常的格式是 ``git-credential-foo [args] <action>.''
标准输入/输出协议和 git-credential 一样，但它们使用的是一套稍微不太一样的行为：

* `get` 是请求输入一对用户名和密码。
* `store` 是请求保存一个凭证到辅助工具的内存。
* `erase` 会将给定的证书从辅助工具内存中清除。

对于 `store` 和 `erase` 两个行为是不需要返回数据的（Git 也会忽略掉）。
然而对于 `get`，Git 对辅助工具的返回信息十分感兴趣。

如果辅助工具没有任何有用的信息，它可以直接退出而不需要输出任何东西，但如果它有这些信息，它在提供的信息后面增加它所拥有的信息。
这些输出会被视为一系列的赋值语句；每一个提供的数据都会将 Git 已有的数据替换掉。

这有一个和上面一样的例子，但是跳过了 git-credential 这一步，直接到 git-credential-store:

[source,console]
----
$ git credential-store --file ~/git.store store <1>
protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <2>
protocol=https
host=mygithost

username=bob <3>
password=s3cre7
----

<1> 我们告诉 `git-credential-store` 去保存凭证：当访问 `https://mygithost` 时使用用户名 ``bob''，密码是 ``s3cre7''。
<2> 现在我们取出这个凭证。
    我们提供连接这部分的信息（`https://mygithost`）以及一个空行。
<3> `git-credential-store` 输出我们之前保存的用户名和密码。

`~/git.store` 文件的内容类似：

[source]
----
https://bob:s3cre7@mygithost
----

仅仅是一系列包含凭证信息URL组成的行。
`osxkeychain` 和 `winstore` 辅助工具使用它们后端存储的原生格式，而 `cache` 使用它的内存格式（其他进程无法读取）。

==== A Custom Credential Cache

Given that `git-credential-store` and friends are separate programs from Git, it's not much of a leap to realize that _any_ program can be a Git credential helper.
The helpers provided by Git cover many common use cases, but not all.
For example, let's say your team has some credentials that are shared with the entire team, perhaps for deployment.
These are stored in a shared directory, but you don't want to copy them to your own credential store, because they change often.
None of the existing helpers cover this case; let's see what it would take to write our own.
There are several key features this program needs to have:

. The only action we need to pay attention to is `get`; `store` and `erase` are write operations, so we'll just exit cleanly when they're received.
. The file format of the shared-credential file is the same as that used by `git-credential-store`.
. The location of that file is fairly standard, but we should allow the user to pass a custom path just in case.

Once again, we'll write this extension in Ruby, but any language will work so long as Git can execute the finished product.
Here's the full source code of our new credential helper:

[source,ruby]
--------
include::../git-credential-read-only[]
--------

<1> Here we parse the command-line options, allowing the user to specify the input file. The default is `~/.git-credentials`.
<2> This program only responds if the action is `get` and the backing-store file exists.
<3> This loop reads from stdin until the first blank line is reached.
    The inputs are stored in the `known` hash for later reference.
<4> This loop reads the contents of the storage file, looking for matches.
    If the protocol and host from `known` match this line, the program prints the results to stdout and exits.

We'll save our helper as `git-credential-read-only`, put it somewhere in our `PATH` and mark it executable.
Here's what an interactive session looks like:

[source,console]
----
$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7
----

Since its name starts with ``git-'', we can use the simple syntax for the configuration value:

[source,console]
----
$ git config --global credential.helper read-only --file /mnt/shared/creds
----

As you can see, extending this system is pretty straightforward, and can solve some common problems for you and your team.
