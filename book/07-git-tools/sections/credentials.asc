[[_credential_caching]]
=== 凭证存储

(((credentials)))
(((git commands, credential)))
如果您使用的是 SSH 方式连接远端，并且设置了一个没有口令的密钥，这样就可以在不输入用户名和密码的情况下安全地传输数据。
然而，这对 HTTP 协议来说是不可能的 —— 每一个连接都是需要用户名和密码的。
这在使用双重认证的情况下会更麻烦，因为您需要输入一个随机生成并且毫无规律的 token 作为密码。

幸运的是，Git 拥有一个凭证系统来处理这个事情。
下面有一些 Git 的选项：

* 默认所有都不缓存。
  每一次连接都会询问您的用户名和密码。
* ``cache'' 模式会将凭证存放在内存中一段时间。
  密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。
* ``sotre'' 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。
  这意味着除非您修改了您在 Git 服务器上的密码，否则您永远不需要再次输入您的凭证信息。
  这种方式的缺点是您的密码是用明文的方式存放在您的 home 目录下。
* 如果您使用的是 Mac，Git 还有一种 ``osxkeychain'' 模式，它会将凭证缓存到您系统用户的钥匙串中。
* The ``store'' mode saves the credentials to a plain-text file on disk, and they never expire.
  这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的。
* 如果您使用的是 Windows，您可以安装一个叫做 ``winstore'' 的辅助工具。
  这和上面说的 ``osxkeychain'' 十分类似，但是是使用 Windows Credential Store 来控制敏感信息。
  可以在 https://gitcredentialstore.codeplex.com[] 下载。

您可以设置 Git 的配置来选择上述的一种方式

[source,console]
----
$ git config --global credential.helper cache
----

部分辅助工具有一些选项的。
``store'' 模式可以接受一个 `--file <path>` 参数，可以自定义存放密码的文件路径（默认是`~/.git-credentials`）。
``cache'' 模式有 `--timeout <seconds>` 参数，可以设置后台进程的存活时间（默认是 ``900''，也就是 15 分钟）。
下面是一个配置 ``store'' 模式自定义路径的例子：

[source,console]
----
$ git config --global credential.helper store --file ~/.my-credentials
----

Git 甚至允许您配置多个辅助工具。
当查找特定服务器的凭证时，Git 会按顺序查询，并且在找到第一个回答时停止查询。
当保存凭证时，Git 会将用户名和密码发送给 *所有* 配置列表中的辅助工具，它们会按自己的方式处理用户名和密码。
如果您在闪存上有一个凭证文件，但又希望在该闪存被拔出的情况下使用内存缓存来保存用户名密码，`.gitconfig` 配置文件如下：

[source,ini]
----
[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000
----

==== Under the Hood

这些是如何实现的呢？
Git 凭证辅助工具系统的命令是 `git credential`，这个命令接收一个参数，并通过标准输入获取更多的参数。

举一个例子更容易理解。
我们假设已经配置好一个凭证辅助工具，这个辅助工具保存了 `mygithost` 的凭证信息。

This might be easier to understand with an example.
Let's say that a credential helper has been configured, and the helper has stored credentials for `mygithost`.
Here's a session that uses the ``fill'' command, which is invoked when Git is trying to find credentials for a host:

[source,console]
----
$ git credential fill <1>
protocol=https <2>
host=mygithost
<3>
protocol=https <4>
host=mygithost
username=bob
password=s3cre7
$ git credential fill <5>
protocol=https
host=unknownhost

Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7
----

<1> This is the command line that initiates the interaction.
<2> Git-credential is then waiting for input on stdin.
    We provide it with the things we know: the protocol and hostname.
<3> A blank line indicates that the input is complete, and the credential system should answer with what it knows.
<4> Git-credential then takes over, and writes to stdout with the bits of information it found.
<5> If credentials are not found, Git asks the user for the username and password, and provides them back to the invoking stdout (here they're attached to the same console).

The credential system is actually invoking a program that's separate from Git itself; which one and how depends on the `credential.helper` configuration value.
There are several forms it can take:

[options="header"]
|======
| Configuration Value | Behavior
| `foo` | Runs `git-credential-foo`
| `foo -a --opt=bcd` | Runs `git-credential-foo -a --opt=bcd`
| `/absolute/path/foo -xyz` | Runs `/absolute/path/foo -xyz`
| `!f() { echo "password=s3cre7"; }; f` | Code after `!` evaluated in shell
|======

So the helpers described above are actually named `git-credential-cache`, `git-credential-store`, and so on, and we can configure them to take command-line arguments.
The general form for this is ``git-credential-foo [args] <action>.''
The stdin/stdout protocol is the same as git-credential, but they use a slightly different set of actions:

* `get` is a request for a username/password pair.
* `store` is a request to save a set of credentials in this helper's memory.
* `erase` purge the credentials for the given properties from this helper's memory.

For the `store` and `erase` actions, no response is required (Git ignores it anyway).
For the `get` action, however, Git is very interested in what the helper has to say.
If the helper doesn't know anything useful, it can simply exit with no output, but it it does know, it should augment the provided information with the information it has stored.
The output is treated like a series of assignment statements; anything provided will replace what Git already knows.

Here's the same example from above, but skipping git-credential and going straight for git-credential-store:

[source,console]
----
$ git credential-store --file ~/git.store store <1>
protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <2>
protocol=https
host=mygithost

username=bob <3>
password=s3cre7
----

<1> Here we tell `git-credential-store` to save some credentials: the username ``bob'' and the password ``s3cre7'' are to be used when `https://mygithost` is accessed.
<2> Now we'll retrieve those credentials.
    We provide the parts of the connection we already know (`https://mygithost`), and an empty line.
<3> `git-credential-store` replies with the username and password we stored above.

Here's what the `~/git.store` file looks like:

[source]
----
https://bob:s3cre7@mygithost
----

It's just a series of lines, each of which contains a credential-decorated URL.
The `osxkeychain` and `winstore` helpers use the native format of their backing stores, while `cache` uses its own in-memory format (which no other process can read).

==== A Custom Credential Cache

Given that `git-credential-store` and friends are separate programs from Git, it's not much of a leap to realize that _any_ program can be a Git credential helper.
The helpers provided by Git cover many common use cases, but not all.
For example, let's say your team has some credentials that are shared with the entire team, perhaps for deployment.
These are stored in a shared directory, but you don't want to copy them to your own credential store, because they change often.
None of the existing helpers cover this case; let's see what it would take to write our own.
There are several key features this program needs to have:

. The only action we need to pay attention to is `get`; `store` and `erase` are write operations, so we'll just exit cleanly when they're received.
. The file format of the shared-credential file is the same as that used by `git-credential-store`.
. The location of that file is fairly standard, but we should allow the user to pass a custom path just in case.

Once again, we'll write this extension in Ruby, but any language will work so long as Git can execute the finished product.
Here's the full source code of our new credential helper:

[source,ruby]
--------
include::../git-credential-read-only[]
--------

<1> Here we parse the command-line options, allowing the user to specify the input file. The default is `~/.git-credentials`.
<2> This program only responds if the action is `get` and the backing-store file exists.
<3> This loop reads from stdin until the first blank line is reached.
    The inputs are stored in the `known` hash for later reference.
<4> This loop reads the contents of the storage file, looking for matches.
    If the protocol and host from `known` match this line, the program prints the results to stdout and exits.

We'll save our helper as `git-credential-read-only`, put it somewhere in our `PATH` and mark it executable.
Here's what an interactive session looks like:

[source,console]
----
$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7
----

Since its name starts with ``git-'', we can use the simple syntax for the configuration value:

[source,console]
----
$ git config --global credential.helper read-only --file /mnt/shared/creds
----

As you can see, extending this system is pretty straightforward, and can solve some common problems for you and your team.
