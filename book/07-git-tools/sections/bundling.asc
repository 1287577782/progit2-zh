[[_bundling]]
=== 打包

虽然我们已经了解了网络传输 Git 数据的常用方法（如 HTTP，SSH 等），但还有另外一种不太常见却又十分有用的方式。

Git 可以将它的数据 ``打包'' 到一个文件中。这在许多场景中都很有用。有可能您的网络中断了，但您又希望将您的提交传给您的合作者们。可能您不在办公网中并且出于安全考虑没有给您接入内网的权限。可能您的无线、有线网卡坏掉了。可能您现在没有共享服务器的权限，您又希望通过邮件将更新发送给别人，却不希望通过 `format-patch` 的方式传输 40 个提交。

这些情况下 `git bundle` 就会很有用。`bundle` 命令会将 `git push` 命令所传输的所有内容打包成一个二进制文件，您可以将这个文件通过邮件或者闪存传给其他人，然后解包到其他的仓库中。

来看看一个简单的例子。假设您有一个包含两个提交的仓库：

[source,console]
----
$ git log
commit 9a466c572fe88b195efd356c3f2bbeccdb504102
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Mar 10 07:34:10 2010 -0800

    second commit

commit b1ec3248f39900d2a406049d762aa68e9641be25
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Mar 10 07:34:01 2010 -0800

    first commit
----

如果您想把这个仓库发送给其他人但您没有其他仓库的权限，或者就是懒得新建一个仓库，您就可以用 `git bundle create` 命令来打包。

[source,console]
----
$ git bundle create repo.bundle HEAD master
Counting objects: 6, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (6/6), 441 bytes, done.
Total 6 (delta 0), reused 0 (delta 0)
----

然后您就会有一个名为 `repo.bundle` 的文件，该文件包含了所有重建该仓库 `master` 分支所需的数据。在使用 `bundle` 命令时，您需要列出所有您希望打包的引用或者提交的区间。如果您希望这个仓库可以在别处被克隆，您应该像例子中那样增加一个 HEAD 引用。

您可以将这个 `repo.bundle` 文件通过邮件或者U盘传给别人。

另一方面，假设别人传给您一个 `repo.bundle` 文件并希望您在这个项目上工作。您可以从这个二进制文件中克隆出一个目录，就像从一个 URL 克隆一样。

[source,console]
----
$ git clone repo.bundle repo
Initialized empty Git repository in /private/tmp/bundle/repo/.git/
$ cd repo
$ git log --oneline
9a466c5 second commit
b1ec324 first commit
----

如果您在打包时没有包含 HEAD 引用，您还需要在命令后指定一个 `-b master` 或者其他被引入的分支，否则 Git 不知道应该检出哪一个分支。

现在假设您提交了 3 个修订，并且要用邮件或者U盘将新的提交放在一个包里传回去。

[source,console]
----
$ git log --oneline
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo
9a466c5 second commit
b1ec324 first commit
----

首先我们需要确认我们希望被打包的提交区间。和网络协议不太一样，网络协议会自动计算出所需传输的最小数据集，而我们需要手动计算。当然您可以像上面那样将整个仓库打包，但最好仅仅打包变更的部分 —— 就是我们刚刚在本地做的 3 个提交。

为了实现这个目标，您需要计算出差别。就像我们在 <<_commit_ranges>> 介绍的，您有很多种方式去指明一个区间提交。我们可以使用 `origin/master..master` 或者 `master ^origin/master` 之类的方法来获取那 3 个在我们的 master 分支而不在原始仓库中的提交。您可以用 `log` 命令来测试。

[source,console]
----
$ git log --oneline master ^origin/master
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo
----

So now that we have the list of commits we want to include in the bundle, let's bundle them up. We do that with the `git bundle create` command, giving it a filename we want our bundle to be and the range of commits we want to go into it.

[source,console]
----
$ git bundle create commits.bundle master ^9a466c5
Counting objects: 11, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (9/9), 775 bytes, done.
Total 9 (delta 0), reused 0 (delta 0)
----

Now we have a `commits.bundle` file in our directory. If we take that and send it to our partner, she can then import it into the original repository, even if more work has been done there in the meantime.

When she gets the bundle, she can inspect it to see what it contains before she imports it into her repository.  The first command is the `bundle verify` command that will make sure the file is actually a valid Git bundle and that you have all the necessary ancestors to reconstitute it properly.

[source,console]
----
$ git bundle verify ../commits.bundle
The bundle contains 1 ref
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
The bundle requires these 1 ref
9a466c572fe88b195efd356c3f2bbeccdb504102 second commit
../commits.bundle is okay
----

If the bundler had created a bundle of just the last two commits they had done, rather than all three, the original repository would not be able to import it, since it is missing requisite history.  The `verify` command would have looked like this instead:

[source,console]
----
$ git bundle verify ../commits-bad.bundle
error: Repository lacks these prerequisite commits:
error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo
----

However, our first bundle is valid, so we can fetch in commits from it.  If you want to see what branches are in the bundle that can be imported, there is also a command to just list the heads:

[source,console]
----
$ git bundle list-heads ../commits.bundle
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
----

The `verify` sub-command will tell you the heads as well.  The point is to see what can be pulled in, so you can use the `fetch` or `pull` commands to import commits from this bundle.  Here we'll fetch the 'master' branch of the bundle to a branch named 'other-master' in our repository:

[source,console]
----
$ git fetch ../commits.bundle master:other-master
From ../commits.bundle
 * [new branch]      master     -> other-master
----

Now we can see that we have the imported commits on the 'other-master' branch as well as any commits we've done in the meantime in our own 'master' branch.

[source,console]
----
$ git log --oneline --decorate --graph --all
* 8255d41 (HEAD, master) third commit - first repo
| * 71b84da (other-master) last commit - second repo
| * c99cf5b fourth commit - second repo
| * 7011d3d third commit - second repo
|/
* 9a466c5 second commit
* b1ec324 first commit
----

So, `git bundle` can be really useful for sharing or doing network-type operations when you don't have the proper network or shared repository to do so.
